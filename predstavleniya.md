# Основные представления:

- Функциональное.
- ## Информационное.
Данное представление имеет смысл в случае Event Sourcing архитектуры. Но так как наша архитектура построенна на классической микросервисной схеме с REST интерфейсами, то все информационные потоки сводятся к REST API архитектуре:


Все микросервисы общаются друг с другом через REST, исключение составляет только домен (микросервис) Message, где его работа завязана как раз на брокере сообщений, условной Kafka в виде consumer/producer

Consumer/Producer (очереди):

- Producer отправляет сообщения в очередь.
- Consumer подключается к очереди и извлекает сообщения для дальнейшей обработки.
- Каждое сообщение отправляется одному потребителю и удаляется из очереди после обработки.

Если какой-то микросервис хочет послать сообщение пользователю - все что от него требуется отправить тело сообщения с мета информацией в специльный топик Kafka, где это сообщение будут обработано и доставлено получателю: микросервису Messaging, который уже полученные сообщение из нужныъ топиков передаст конкретному нужному клиенту
 Это позволяет сделать систему более гибкой и надежной: существует гарантия доставки и обработки сообщения.

 ![Kafka](https://github.com/butorovnv/Software-Architecture-Diploma/blob/main/images/kafka.png)

- ## Многозадачность (concurrency).
  
Поскольку функциональность интернет-магазина считается уже реализованной согласно заданию, любые вопросы, касающиеся многопоточности (например, устранение гонки состояний и аналогичных проблем), будут решаться на стороне владельца API, предоставляющего доступ к своей инфраструктуре. Наша компания строго придерживается правил данного API и осуществляет необходимые интеграционные процессы.


Относительно собственных приложений: 
Реализация многозадачности в мобильных приложениях через создание нескольких экземпляров (реплик инстансов) чаще всего связана с использованием параллельных процессов или потоков выполнения (threads). Однако мобильные устройства имеют ограниченный объем ресурсов, такие как оперативная память и процессорное время, поэтому использование множества отдельных процессов не всегда целесообразно и никиких трудностей с параллельностью не опредвитися.
 Если нагрузка возрастёт, поставщик услуг поднимет дополнительные интаны нашего приложения для снижения задержек в запроса. Большое число одновременно функционирующих экземпляров приложений не создаст взаимных помех, поскольку сами приложения не хранят локальных состояний — вся необходимая информация хранится централизованно в базе данных, доступной каждому приложению.





- Инфраструктурное.




- ## Безопасность

Основным инструментом для обеспечения безопасности будет система аутентификации/авторизации на основе JSON Web Tokens (JWT) — это открытый стандарт (RFC 7519) для создания токенов доступа, основанный на формате JSON.   


Структура JWT:  
JWT состоит из трех частей: заголовок header, полезные данные payload и подпись signature  

Приложение использует JWT для проверки аутентификации пользователя следующим образом:
1. Сперва пользователь заходит на сервер аутентификации с помощью аутентификационного ключа (это может быть пара логин/пароль, либо Facebook ключ, либо Google ключ, либо ключ от другой учетки).
2. Затем сервер аутентификации создает JWT и отправляет его пользователю.
3. Когда пользователь делает запрос к API приложения, он добавляет к нему полученный ранее JWT.
4. Когда пользователь делает API запрос, приложение может проверить по переданному с запросом JWT является ли пользователь тем, за кого себя выдает. В этой схеме сервер приложения сконфигурирован так, что сможет проверить, является ли входящий JWT именно тем, что был создан сервером аутентификации 

    ![JWT](https://github.com/butorovnv/Software-Architecture-Diploma/blob/main/images/JWT2.jpeg)


Помимо этого важно предусмотреть систему ограничения частоты запросов (троттлинг), обеспечивающую минимальную защиту от простых DDoS-атак. Это ограничение можно реализовать как непосредственно на уровне нашего модуля аутентификации, так и используя возможности шлюза API Gateway, предоставляемого Google Cloud Platform.


Все взаимодействия с приложением осуществляются исключительно по протоколу HTTPS с автоматической переадресацией с HTTP. Этот шаг защищает от различных сетевых атак типа прослушивания трафика или внедрения вредоносных элементов в сеть. Передаваемые злоумышленнику данные окажутся зашифрованы, и без наличия сертификатов, установленных на сервере, расшифровка окажется невозможной.

![TLS](https://github.com/butorovnv/Software-Architecture-Diploma/blob/main/images/TLS.png)

