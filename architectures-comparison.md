# 1.10 Анализ и описание архитектурных опций и обоснование выбора

В таблице приводится сравнительный анализ различных типов архитектур. В каждой ячейке на пересечении типа архитектуры и атрибута качества указана оценка по 5-балльной шкале, где 5 - наилучшая оценка, 1 - наихудшая.


|     | Монолит    | Service-Oriented    | Service-Based     | Space-Based     | Event-Driven    | Microservices   |
| ------------ | ------------ | ------------ | ------------ | ------------ | ------------ | ------------ |
| Agility / Гибкость| **2** (перестроить на новый бизнес-процесс или новый стек - проблематично, придется перепроектировать все приложение)| **3,5** (сервисы условно независимы, но имеют связанность из-за общих ресурсов и централизованной коммуникации)| **4** (сервисы хорошо разделены, но они довольно массивные)| **4,5** (за счет распределения данных и параллельной обработки проще приспособление к новым задачам или дополнительным требованиям)| **5** (наличие управления событиями через брокер, медиатор| **5** (можно выбрать стек под каждый микросервис)|
| Cost / Стоимость | **2** (единый стек технологий - дороже доработка)| **4** (адаптация инфраструктуры к меняющимся потребностям без дорогостоящих модификаций или повторной разработки| **4** (адаптация инфраструктуры к меняющимся потребностям без дорогостоящих модификаций или повторной разработки)| **3** (расходы на инфраструктуру, связанные с управлением и обслуживанием нескольких узлов + на интеграции)| **3** (высокая модульность и расширяемость снижает затраты, но необходимость в брокерах сообщений и управлении распределёнными компонентами увеличивает расходы на инфраструктуру)| **2** (у каждого нового микросервиса своя стоимость разработки, тестов, инфраструктуры и т.д. чем больше микросервисов, тем выше стоимость)|
| Deployability / Развертываемость | **4** (единый автономный модуль, но очень громоздкий)| **2** (Обычно подразумевает развертывание всего приложения как единого блока, невозможнос развернуть по одному из-за единой ESB)| **4** (каждый сервис можно развернуть отдельно, можно разбить API и базы данных на несколько развертываемых единиц)| **5** (Легкое развертывание модулей, т.к они могут быть упакованы в независимые и самостоятельные блоки, что позволяет выполнять обновление и развертывание без влияния на всю систему. ( blue-green deployment))| **5** (позволяет разделить компоненты, что упрощает развертывание и обновление отдельных компонентов без влияния на всю систему) |**5** (микросервисы представляют собой отдельные модули, поэтому их можно разворачивать независимо)|
| Integration / Интеграция| **4** (особенно, если этот монолит - producer с существующим контрактом) Рассматриваем внешние интеграции| **3** (интеграция черед центр интеграции в ESB с определнным контрактом )| **5** (интеграция возможна через слой API, в котором доступны все необходимые элементы единого контракта и взаиможейсвтия сервисов)| **4** (опора этой архитектуры - передача сообщений или управляемая эвентами коммуникация между компонентами, что упрощает создание и интеграцию новых функций)| **3** (сложное управление (создание и поддержка) контрактов сервисов, т.к необходимо много зависимостей для мидиатора, брокеров сообщений) |**4** (можно сделать отдельный контракт для каждого из сервсов, использовать разные стеки, что удобно, но поддерживать и разрабатывать сложнее)|
| Performance / Производительность| **3** (с одной стороны - загружен всегда один сервер процессом, но если возрастен нагрузка на один сервер - все посыпется| **2** (т.к необходимо пропускать все через единую ESB, у которой канал с определнной пропускной способностью)| **4** (возможность компоновки сервисов и работа с хранилищем данных через схемы или отдельные БД, продвинутой балансировкой, но есть потенциальная задержка в коммуникации между сервисами)| **5** (параллельная обработка и кэширование в памяти для чтения данных, SBA позволяет использовать процессинговые единицы— отдельных модулей, способных работать параллельно) | **5** (асинхронное взаимодействие, параллельная обработка, легко наращивать производительность при обработке сообщений) | **4** (сложнее поддерживать их взаимодействие и согласованность данных, но при этом нагрузка распределена на каждом из сервисов либо архтектурно, либо балансировщиком)|
| Scalability / Масштабируемость| **1** (система масштабируется как единое целое, горизонтальное масшитабирование почти нереально, нерационально расходуются ресурсы)| **3** (масштабируется горизонтально, но масштабирование может быть затруднено из-за централизованной коммуникации) | **3** (масштабируется горизонтально, масштабирование может быть затруднено в случае централизованной БД)| **5** (нет зависимости от одной БД, возможно добавлять узлы по мере увеличения нагрузки, Масштабирование в SBA осуществляется за счет добавления новых процессинговых единиц, но дополнительные требования к грануляции данных) | **5** (высокая масштабируемость за счет горизонтального масштабирования путем программного добавления обработчиков событий) | **5** (когда микросервис достигает предельной нагрузки, можно развернуть новые экземпляры автоматически. Микросервисы можно масштабировать независимо друг от друга)|
| Testability / Тестируемость| **5** (единый стек)| **3** (усложненное тестирование, тк общее хранилище с другими модулями и зависимость от них)| **4** (есть возможность тестирования отдельных модулей без зависимостей от общего хранилища)| **2** (усложнено необходимостью обеспечить корректное взаимодействие и согласованность данных между узлами) | **4** (отдельные компоненты легко тестировать, но взаимодействия между ними (например, потоками событий) сложны из-за асинхронности и недетерминированности в потоках событий) |**3** (у каждого микросервиса свой набор журналов, что усложняет отладку. С другой стороны, в отдельных сервисах легче находить и исправлять баги)|

На основании проведенного анализа был сделан выбор в пользу микросервисной архитектуры с подходом Domain Driven Design, т.к у нас есть четко выделенные бизнес-модули,каждый из которых выполняет свой определенный функционал и имеет виидмые граница как для разработки, так и для бизнеса  

Безусловно, у микросервисной архитектуры с подходом DDD есть свои минусы, такие как: 
- Высокая стоимость разработки
- Много различных требований к инфратсруктуре каждого микросервиса
- ставновится больше усзлов, на которых может повлиять сетевая недоступность (точки отказа и тд)
- Необходимо учитывать дополнительные репликации, балансировки нагрузки
  
Но учитывая, что у нас 90% всех систем, используемых в компании, расположены у облачных провайдеров, то решение в виде облачной модели PaaS (Platform as a service), в которой предоставляется готовый набор ресурсов для разработки, тестирования, развертывания, масштабирования прлиожений - позволяет нам не беспокоиться об инфраструктуре и доступности, а сконцентрироваться на реалзиации функционала и обновлении приложения, без рисков недоступности и тд.
Сравнивая облачные решения, выброр пал на PaaS, т.к он предлагает всю нужную инфраструктуту, при этом давая вохможность реализовывать собственный интерфейс и приложение, а IaaS'а нам будет недостаточно

![PaaS](https://github.com/butorovnv/Software-Architecture-Diploma/blob/main/images/PAAAS.png)


БД и основной стек
1. Основное хранилище данных. Основная база данных должна быть реляционной, т.к будет хранить хранить структурированную информацию о пользователях, товарах, заказах, сообществах и другом контенте. Oracle  или PostgreSQL отлично подойдет для наших целей как наиболее популярное и зарекомендовавшее себя решение, а также благодаря  поддержке ACID-транзакций, что гарантирует целостность данных даже при большом объеме одновременных обращений.
2. Время-событийные данные. Для эффективного накопления огромного объема данных с датчиков и фитнес-трекеров (таких как количество шагов, скорость движения, продолжительность тренировок и т.п.) подойдут БД временных рядов. Будем использовать TimescaleDB, т.к он хорошо интегрируется с  выбранной ранее PostgreSQL
3. Хранение динамических данных. Все социальные данные (комментарии, лайки, посты, уведомления) это динамические данные, которые сложно хранить в жесткой структуре таблиц. MongoDB обеспечивает хорошую производительность и простоту администрирования для подобной информации, особенно для больших объёмов. Cassandra может подойти, если важна высокая доступность и устойчивость к сбоям серверов.
4. Кэш. 
Для кэширования наиболее частых запросов с хранением краткосрочной информации будем использовать Redis( топ-списков популярных товаров, тренировок и тд). Redis обеспечивает быструю запись и чтение, снижая нагрузку на основную базу данных.
5. Микросервисная инфраструктура:
Docker: Контейнеры позволят упростить развёртывание и независимую доставку изменений.
Kubernetes: Оркестратор контейнеров, позволяющий удобно запускать большое число экземпляров микросервисов, балансируя нагрузку и управляя масштабированием.
RabbitMQ/Kafka: Службы сообщений для асинхронного общения между компонентами системы.
